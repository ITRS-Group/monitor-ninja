<?php defined('SYSPATH') OR die('No direct access allowed.');

/**
 * Handle comments for hosts and services
 */
class Comment_Model extends Model {
	/***************************** COMMENT TYPES *******************************/
	const HOST_COMMENT = 1; /**< Comment applies to host */
	const SERVICE_COMMENT = 2; /**< Comment applies to service */

	/****************************** ENTRY TYPES ********************************/
	const USER_COMMENT = 1; /**< Comment is entered by user */
	const DOWNTIME_COMMENT = 2; /**< Comment is generated by a downtime */
	const FLAPPING_COMMENT = 3; /**< Comment is generated because object is flapping */
	const ACKNOWLEDGEMENT_COMMENT = 4; /**< Comment is generated from an acknowledgement */

	const TABLE_NAME = 'comment_tbl'; /**< The name of the comment table */

	/**
	 * Generate basic SQL for fetching comments. Takes care to join correctly with contact_access
	 *
	 * Used by both fetch_comments_by_* methods.
	 */
	protected static function gen_fetch_comment_query($for_services = false, $count = false) {
		$auth = Nagios_auth_Model::instance();

		if ($auth->{'view_'.($for_services?'services':'hosts').'_root'}) {
			$filter = '';
		} else if ($for_services) {
			$filter = 'INNER JOIN service s ON c.host_name = s.host_name '.
				'AND c.service_description = s.service_description '.
				'INNER JOIN contact_access ca ON s.id = ca.service '.
				'AND ca.contact = '.$auth->id;
		} else {
			$filter = 'INNER JOIN host h ON c.host_name = h.host_name '.
				'INNER JOIN contact_access ca ON h.id = ca.host '.
				'AND ca.contact = '.$auth->id;
		}

		$fields = $count? 'COUNT(1) AS cnt' : 'c.*';

		$sql = 'SELECT '.$fields.' FROM '.static::TABLE_NAME.' c '.$filter.' ';

		return $sql;
	}
	/**
	 * Fetch saved comments for host or service
	 *
	 * @param $host string Host name - must be set
	 * @param $service string Service description, or false to get comments for a host
	 * @param $num_per_page int Number of rows to retrieve
	 * @param $offset int Number of rows to skip before retrieving first row
	 * @param $count bool Completely ignore the two previous options - return the total number of comments instead of the comments themselves
	 * @returns If $count is true, then the number of rows as an int, otherwise the database result of comments
	 */
	public static function fetch_comments_by_object($host=false, $service=false, $num_per_page=false, $offset=false, $count=false)
	{
		$host = trim($host);
		$service = trim($service);
		$num_per_page = (int)$num_per_page;
		$offset = (int)$offset;
		if (empty($host)) {
			return false;
		}
		$db = Database::instance();
		$auth = Nagios_auth_Model::instance();

		$base_sql = static::gen_fetch_comment_query($service != false, $count);

		$svc_selection = empty($service) ?
			'AND c.service_description IS NULL' :
			'AND c.service_description='.$db->escape($service);

		# only use LIMIT when NOT counting
		$offset_limit = $count!==false || empty($num_per_page) ? "" : " LIMIT " . $num_per_page." OFFSET ".$offset;

		$sql = $base_sql.'WHERE c.host_name='.$db->escape($host).' '.$svc_selection;
		if (!$count)
			$sql .= " ORDER BY c.entry_time, c.host_name ".$offset_limit;

		$result = $db->query($sql)->result();
		if ($count !== false) {
			return $result ? $result->current()->cnt : 0;
		}
		return $result;
	}

	/**
	 * Fetch all host or all service comments the current user may see
	 *
	 * @param $for_services bool If true, fetch service comments, else fetch host comments
	 * @param $num_per_page int Number of rows to retrieve
	 * @param $offset int Number of rows to skip before retrieving first row
	 * @param $count bool Completely ignore the two previous options - return the total number of comments instead of the comments themselves
	 * @returns If $count is true, then the number of rows as an int, otherwise the database result of comments
	 */
	public static function fetch_comments_by_user($for_services=false, $num_per_page=false, $offset=false, $count=false)
	{
		$num_per_page = (int)$num_per_page;
		$offset = (int)$offset;

		$db = Database::instance();
		$auth = Nagios_auth_Model::instance();

		$sql = static::gen_fetch_comment_query($for_services, $count);

		$offset_limit = $count!==false || empty($num_per_page) ? "" : " LIMIT " . $num_per_page." OFFSET ".$offset;

		if (!$count) {
			if($for_services) {
				$sql .= " WHERE c.service_description IS NOT NULL ";
			} else {
				$sql .= " WHERE c.service_description IS NULL ";
			}
			$sql .= " ORDER BY c.entry_time, c.host_name ".$offset_limit;
		}
		$result = $db->query($sql)->result();
		if ($count !== false) {
			return $result ? $result->current()->cnt : 0;
		}

		return $result;
	}

	/**
	 * Fetch all comments of a specified type for a specified host or service
	 * @param $entry_type The comment type as an integer
	 * @param $host_name Host name
	 * @param $service_description Service description, or empty to fetch for host
	 * @return DB result, or false on error or empty
	 */
	public static function fetch_all_comment_types($entry_type, $host_name, $service_description) {

		$db = Database::instance();
		switch ($entry_type) {
			case 1: // user comment
			case 3: // flapping
			case 4: // acknowledged
				$type = static::TABLE_NAME;
				break;
			case 2: // downtime
				$type = 'scheduled_downtime';
				break;
			default:
				die("What did you do!?");
				break;
		}
		$and = empty($service_description) ? '' : " AND service_description='".$service_description."'";
		$sql = "SELECT comment_data from ".$type." where host_name = '".$host_name."'".$and."";
		$result = $db->query($sql);

		return $result->count() ? $result->result() : false;
	}

	/**
	*	Wrapper method to fetch nr of comments for host or service
	*/
	public static function count_comments_by_object($host=false, $service=false)
	{
		return static::fetch_comments_by_object($host, $service, false, false, true);
	}

	/**
	*	Wrapper method to fetch a count of all service- or host comments
	*/
	public static function count_comments_by_user($host=false, $service=false)
	{
		return static::fetch_comments_by_user($service, false, false, true);
	}

	/**
	*	Fetch comment counts for all objects that has comments
	*	Returned array will contain object name as key and count
	* 	as value for all objects with comments.
	*/
	public static function count_all_comments_by_object($service=false)
	{
		if ($service === false) { # only host comments
			$sql = "SELECT COUNT(*) as cnt, host_name as obj_name FROM ".static::TABLE_NAME." WHERE ".
			"service_description = '' OR service_description is NULL ".
			"GROUP BY host_name ORDER BY host_name";
		} else { # service comments
			$sql = "SELECT count(*) as cnt, obj_name FROM (SELECT ".sql::concat('host_name', ';', 'service_description')." AS obj_name FROM ".static::TABLE_NAME." WHERE ".
			"service_description != '' OR service_description is not NULL) tmpname ".
			"GROUP BY obj_name ORDER BY obj_name";
		}

		$db = Database::instance();
		$result = $db->query($sql);
		if (!$result || count($result) == 0) {
			return false;
		}
		$data = false;
		foreach ($result as $row) {
			if ($row->cnt != 0) {
				$data[$row->obj_name] = $row->cnt;
			}
		}
		return $data;
	}

	/**
	*	Search through several fields for a specific value
	*/
	public function search($value=false, $limit=false)
	{
		if (empty($value)) return false;
		$db = Database::instance();
		$auth = Nagios_auth_Model::instance();
		$contact_id = (int)$auth->id;
		$limit_str = sql::limit_parse($limit);
		$join_host = false;
		$where_host = false;
		$join_svc = false;
		$where_svc = false;
		if (!$auth->view_hosts_root) {
			$join_host = "INNER JOIN contact_access ON host.id = contact_access.host ";
			$where_host = "AND contact_access.contact = ".$contact_id." ";
			$join_svc = "INNER JOIN contact_access ON service.id = contact_access.service ";
			$where_svc = "AND contact_access.contact = ".$contact_id." ".
				"AND service.host_name = host.host_name ";
		}
		if (is_array($value) && !empty($value)) {
			$query = false;
			$sql = false;
			foreach ($value as $val) {
				$val = '%'.$val.'%';
				$query[] = "SELECT c.id FROM ".static::TABLE_NAME." c ".
				" INNER JOIN host on host.host_name = c.host_name ".$join_host.
				" WHERE (LCASE(comment_data) LIKE LCASE(".$db->escape($val).") OR ".
				"LCASE(c.host_name) LIKE LCASE(".$db->escape($val).") ) ".
				" AND c.service_description IS NULL ".$where_host.
				" UNION ".
				"SELECT c.id FROM ".static::TABLE_NAME." c ".
				"INNER JOIN host on host.host_name = c.host_name ".
				"INNER JOIN service ON service.service_description = c.service_description ".$join_svc.
				" WHERE (LCASE(comment_data) LIKE LCASE(".$db->escape($val).") OR ".
				"LCASE(c.host_name) LIKE LCASE(".$db->escape($val).") OR ".
				"LCASE(c.service_description) LIKE LCASE(".$db->escape($val).") ) ".
				" AND c.service_description IS NOT NULL ".
				"AND service.host_name = host.host_name ".$where_svc;
			}
			if (!empty($query)) {
				$sql = 'SELECT * FROM '.static::TABLE_NAME.' WHERE id IN ('.implode(' UNION ', $query).') ORDER BY host_name, service_description, entry_time '.$limit_str;
			}
		} else {
			$value = '%'.$value.'%';
			$sql = "(SELECT c.* FROM ".static::TABLE_NAME." c ".
				" INNER JOIN host on host.host_name = c.host_name ".$join_host.
				"WHERE (LCASE(comment_data) LIKE LCASE(".$db->escape($value).") OR ".
				"LCASE(c.host_name) LIKE LCASE(".$db->escape($value).") )".
				" AND c.service_description IS NULL ".$where_host.
				") UNION ALL (".
				"SELECT c.* FROM ".static::TABLE_NAME." c ".
				"INNER JOIN host on host.host_name = c.host_name ".
				"INNER JOIN service ON service.service_description = c.service_description ".$join_svc.
				"WHERE (LCASE(comment_data) LIKE LCASE(".$db->escape($value).") OR ".
				"LCASE(c.host_name) LIKE LCASE(".$db->escape($value).") OR ".
				"LCASE(c.service_description) LIKE LCASE(".$db->escape($value).") ) ".
				"AND c.service_description IS NOT NULL ".
				"AND service.host_name = host.host_name ".$where_svc." )".$limit_str;
		}
		$obj_info = $db->query($sql);
		return $obj_info;
	}

	/**
	*	Fetch comment info filtered on specific field and value
	*/
	public function get_where($field=false, $value=false, $limit=false)
	{
		if (empty($field) || empty($value)) {
			return false;
		}
		$db = Database::instance();
		$auth = Nagios_auth_Model::instance();
		$field = trim($field);
		$value = trim($value);
		$contact_id = (int)$auth->id;
		$limit_str = sql::limit_parse($limit);
		$join_host = false;
		$where_host = false;
		$join_svc = false;
		$where_svc = false;
		if (!$auth->view_hosts_root) {
			$join_host = "INNER JOIN contact_access ON host.id = contact_access.host ";
			$where_host = "AND contact_access.contact = ".$contact_id;
			$join_svc = "INNER JOIN contact_access ON service.id = contact_access.service ";
			$where_svc = "AND contact_access.contact = ".$contact_id." AND service.host_name = host.host_name ";;
		}

		$limit_str = sql::limit_parse($limit);
		$value = '%' . $value . '%';
		$sql = "(SELECT c.* FROM ".static::TABLE_NAME." c ".
			" INNER JOIN host on host.host_name = c.host_name ".$join_host.
			"WHERE LCASE(".$field.") LIKE LCASE(".$db->escape($value).")".
			" AND c.service_description IS NULL ".$where_host.
			") UNION ALL (".
			"SELECT c.* FROM ".static::TABLE_NAME." c ".
			"INNER JOIN host on host.host_name = c.host_name ".
			"INNER JOIN service ON service.service_description = c.service_description ".$join_svc.
			"WHERE LCASE(".$field.") LIKE LCASE(".$db->escape($value).") ".
			"AND c.service_description IS NOT NULL ".
			"AND service.host_name = host.host_name ".$where_svc." )".$limit_str;
		$obj_info = $db->query($sql);
		return count($obj_info) > 0 ? $obj_info : false;
	}

}
